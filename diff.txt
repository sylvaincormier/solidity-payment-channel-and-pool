diff --git a/src/LPToken.sol b/src/LPToken.sol
index d8843e6..a145cad 100644
--- a/src/LPToken.sol
+++ b/src/LPToken.sol
@@ -2,21 +2,29 @@
 pragma solidity ^0.8.20;
 
 import "openzeppelin-contracts/token/ERC20/ERC20.sol";
+import "forge-std/console2.sol";
 
 contract LPToken is ERC20 {
     address public immutable pool;
 
-    constructor() ERC20("LP Token", "LP") {
+    constructor() ERC20("Liquidity Pool Token", "LPT") {
         pool = msg.sender;
+        console2.log("LP Token constructor - Pool address set to:", msg.sender);
     }
 
-    function mint(address to, uint256 amount) external {
+    function mint(address account, uint256 amount) external {
+        console2.log("LP Token mint called by:", msg.sender);
+        console2.log("Minting to address:", account);
+        console2.log("Amount:", amount);
+        
         require(msg.sender == pool, "Only pool can mint");
-        _mint(to, amount);
+        require(account != address(0), "Cannot mint to zero address");
+        _mint(account, amount);
     }
 
-    function burn(address from, uint256 amount) external {
+    function burn(address account, uint256 amount) external {
         require(msg.sender == pool, "Only pool can burn");
-        _burn(from, amount);
+        require(account != address(0), "Cannot burn from zero address");
+        _burn(account, amount);
     }
 }
\ No newline at end of file
diff --git a/src/LiquidityPool.sol b/src/LiquidityPool.sol
index 6af8ae6..aa36676 100644
--- a/src/LiquidityPool.sol
+++ b/src/LiquidityPool.sol
@@ -15,10 +15,14 @@ contract LiquidityPool is ReentrancyGuard {
     
     uint256 public reserveA;
     uint256 public reserveB;
+    uint256 public lastK;  // Store k (reserveA * reserveB) for manipulation checks
     
     uint256 public constant MINIMUM_LIQUIDITY = 1000;
     uint256 private constant FEE_DENOMINATOR = 1000;
     uint256 private constant FEE_NUMERATOR = 3; // 0.3% fee
+    uint256 private constant MINIMUM_TRADE_DELAY = 2; // blocks
+    
+    mapping(address => uint256) public lastTradeBlock;  // Track last trade block for each user
 
     // Events
     event LiquidityAdded(address indexed provider, uint256 amountA, uint256 amountB, uint256 liquidity);
@@ -31,29 +35,56 @@ contract LiquidityPool is ReentrancyGuard {
         tokenA = IERC20(_tokenA);
         tokenB = IERC20(_tokenB);
         lpToken = new LPToken();
+        console2.log("LP Token deployed at:", address(lpToken));
     }
 
     function getReserves() public view returns (uint256, uint256) {
         return (reserveA, reserveB);
     }
 
+    function _updateAndCheckK() private {
+        uint256 newK = reserveA * reserveB;
+        if (lastK != 0) {
+            require(newK >= lastK, "K value decreased");
+        }
+        lastK = newK;
+    }
+
+    function _checkTradeDelay() private {
+        require(
+            block.number >= lastTradeBlock[msg.sender] + MINIMUM_TRADE_DELAY,
+            "Must wait before trading again"
+        );
+        lastTradeBlock[msg.sender] = block.number;
+    }
+
     function addLiquidity(uint256 amountADesired, uint256 amountBDesired) 
         external 
         nonReentrant 
         returns (uint256 amountA, uint256 amountB, uint256 liquidity) 
     {
-        // Transfer tokens to this contract
+        require(amountADesired >= MINIMUM_LIQUIDITY, "Insufficient token A amount");
+        require(amountBDesired >= MINIMUM_LIQUIDITY, "Insufficient token B amount");
+        
         tokenA.transferFrom(msg.sender, address(this), amountADesired);
         tokenB.transferFrom(msg.sender, address(this), amountBDesired);
 
-        // Calculate amounts
         uint256 _reserveA = reserveA;
         uint256 _reserveB = reserveB;
 
         if (_reserveA == 0 && _reserveB == 0) {
-            (amountA, amountB) = (amountADesired, amountBDesired);
+            uint256 minDesired = Math.min(amountADesired, amountBDesired);
+            (amountA, amountB) = (minDesired, amountBDesired);
             liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;
-            lpToken.mint(address(0), MINIMUM_LIQUIDITY); // Lock the minimum liquidity
+            console2.log("Initial liquidity calculated:", liquidity);
+            console2.log("Sender address:", msg.sender);
+            
+            // For the first deposit, we need to handle minimum liquidity
+            if (liquidity <= 0) revert("Insufficient initial liquidity");
+            
+            // Mint minimum liquidity first
+            console2.log("Minting minimum liquidity to:", msg.sender);
+            lpToken.mint(msg.sender, MINIMUM_LIQUIDITY);
         } else {
             uint256 amountBOptimal = quote(amountADesired, _reserveA, _reserveB);
             if (amountBOptimal <= amountBDesired) {
@@ -70,11 +101,10 @@ contract LiquidityPool is ReentrancyGuard {
 
         require(liquidity > 0, "Insufficient liquidity minted");
 
-        // Update reserves
         reserveA += amountA;
         reserveB += amountB;
+        _updateAndCheckK();
 
-        // Refund excess tokens
         if (amountA < amountADesired) {
             tokenA.transfer(msg.sender, amountADesired - amountA);
         }
@@ -91,20 +121,31 @@ contract LiquidityPool is ReentrancyGuard {
         nonReentrant 
         returns (uint256 amountA, uint256 amountB) 
     {
-        // Transfer LP tokens from user
-        lpToken.burn(msg.sender, liquidity);
-
-        // Calculate token amounts
-        amountA = (liquidity * reserveA) / lpToken.totalSupply();
-        amountB = (liquidity * reserveB) / lpToken.totalSupply();
-
+        require(liquidity > 0, "Invalid liquidity amount");
+        uint256 totalSupply = lpToken.totalSupply();
+        require(totalSupply > 0, "No supply");
+        
+        // Calculate proportional token amounts before burning tokens
+        amountA = (liquidity * reserveA) / totalSupply;
+        amountB = (liquidity * reserveB) / totalSupply;
         require(amountA > 0 && amountB > 0, "Insufficient liquidity burned");
 
         // Update reserves
-        reserveA -= amountA;
-        reserveB -= amountB;
-
-        // Transfer tokens to user
+        uint256 balanceA = reserveA;
+        uint256 balanceB = reserveB;
+        reserveA = balanceA - amountA;
+        reserveB = balanceB - amountB;
+
+        // Check K value before burning tokens
+        uint256 oldK = balanceA * balanceB;
+        uint256 newK = reserveA * reserveB;
+        // require(newK >= oldK * (totalSupply - liquidity) / totalSupply, "K value decreased");
+        require(
+            newK >= (oldK * (totalSupply - liquidity)**2) / (totalSupply**2),
+            "K value decreased" 
+        );
+        // Burn LP tokens and transfer tokens
+        lpToken.burn(msg.sender, liquidity);
         tokenA.transfer(msg.sender, amountA);
         tokenB.transfer(msg.sender, amountB);
 
@@ -117,28 +158,42 @@ contract LiquidityPool is ReentrancyGuard {
         returns (uint256 amountOut) 
     {
         require(amountIn > 0, "Insufficient input amount");
+        require(amountIn >= MINIMUM_LIQUIDITY, "Below minimum swap amount");
+        
+        _checkTradeDelay();
+        
         (uint256 _reserveA, uint256 _reserveB) = getReserves();
         require(_reserveA > 0 && _reserveB > 0, "Insufficient liquidity");
 
-        // Calculate amount out
+        uint256 balanceBefore = isAtoB ? 
+            tokenA.balanceOf(address(this)) : 
+            tokenB.balanceOf(address(this));
+
         if (isAtoB) {
             amountOut = getAmountOut(amountIn, _reserveA, _reserveB);
-            // Transfer tokens
+            require(amountOut <= _reserveB / 3, "Output amount too large");
+            
             tokenA.transferFrom(msg.sender, address(this), amountIn);
             tokenB.transfer(msg.sender, amountOut);
-            // Update reserves
             reserveA += amountIn;
             reserveB -= amountOut;
         } else {
             amountOut = getAmountOut(amountIn, _reserveB, _reserveA);
-            // Transfer tokens
+            require(amountOut <= _reserveA / 3, "Output amount too large");
+            
             tokenB.transferFrom(msg.sender, address(this), amountIn);
             tokenA.transfer(msg.sender, amountOut);
-            // Update reserves
             reserveB += amountIn;
             reserveA -= amountOut;
         }
 
+        // Verify actual balance changes match expected changes
+        uint256 balanceAfter = isAtoB ? 
+            tokenA.balanceOf(address(this)) : 
+            tokenB.balanceOf(address(this));
+        require(balanceAfter >= balanceBefore + amountIn, "Balance manipulation detected");
+        
+        _updateAndCheckK();
         emit Swap(msg.sender, amountIn, amountOut, isAtoB);
     }
 
diff --git a/src/TestTokens.sol b/src/TestTokens.sol
index 4219aa1..3792f48 100644
--- a/src/TestTokens.sol
+++ b/src/TestTokens.sol
@@ -4,21 +4,19 @@ pragma solidity ^0.8.20;
 import "openzeppelin-contracts/token/ERC20/ERC20.sol";
 
 contract TestTokenA is ERC20 {
-    constructor() ERC20("Test Token A", "TTA") {
-        _mint(msg.sender, 1000000 * 10**decimals());
-    }
+    constructor() ERC20("Test Token A", "TTA") {}
 
-    function mint(address to, uint256 amount) external {
-        _mint(to, amount);
+    function mint(address account, uint256 amount) public {
+        require(account != address(0), "TestToken: mint to the zero address");
+        _mint(account, amount);
     }
 }
 
 contract TestTokenB is ERC20 {
-    constructor() ERC20("Test Token B", "TTB") {
-        _mint(msg.sender, 1000000 * 10**decimals());
-    }
+    constructor() ERC20("Test Token B", "TTB") {}
 
-    function mint(address to, uint256 amount) external {
-        _mint(to, amount);
+    function mint(address account, uint256 amount) public {
+        require(account != address(0), "TestToken: mint to the zero address");
+        _mint(account, amount);
     }
 }
\ No newline at end of file
